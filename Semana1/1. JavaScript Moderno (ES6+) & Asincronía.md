> [!INFO] Objetivo de la clase
>Actualizar el "chip" mental. En React no usamos bucles `for`, ni modificamos variables directamente, ni usamos `function` antigua. Hoy aprenderemos la sintaxis que usarás el 90% del tiempo en el curso.

---
# 1. El cambio de mentalidad

No son solo una forma más corta de escribir; cambian cómo escribimos lógica visual.
## Diferencias Clave

1.  **Sintaxis Concisa:** Menos ruido visual.
2.  **Retorno Implícito:** Si hay una sola línea, no necesitas `return` ni `{}`. (Vital para componentes visuales).
## Análisis de Código

```JavaScript
// JAVASCRIPT ANTIGUO (Imperativo)
function sumarv1(a, b) {
    return a + b;
}

// JAVASCRIPT MODERNO (Arrow Function)
const sumarv2 = (a, b) => {
    return a + b;
}
// RETORNO IMPLÍCITO (La forma más común en React)
// "Si lo que sigue a la flecha es una expresión, retórnala automáticamente"
const sumarv3 = (a, b) => a + b;

console.log(sumarv1(2, 3));
console.log(sumarv2(2, 3));
console.log(sumarv3(2, 3));
```
---
# 2. Desestructuración (Destructuring)

La capacidad de "sacar" datos de objetos y arreglos y convertirlos en variables individuales en un solo paso.
## Desestructuración de Objetos

Extraer propiedades por su nombre.

```JavaScript
const usuario = {
    nombre: "Ana",
    edad: 28,
    ciudad: "Cochabamba",
    redes: { twitter: "@ana", facebook:"@ana" }
};

// Forma vieja
const nombre = usuario.nombre;
const ciudad = usuario.ciudad;

// Forma moderna
// "Busca la propiedad 'nombre' y 'ciudad' dentro de usuario y crea variables"
const { nombre, ciudad } = usuario;

// También funciona con objetos anidados
const { twitter } = usuario.redes;
```

## Desestructuración de Arreglos

Extraer elementos por su posición. (Base de los Hooks como useState).

```JavaScript

const personajes = ["Goku", "Vegeta", "Trunks"];

// "El primero se llamará p1, el segundo p2"
const [p1, p2] = personajes; 

console.log(p1); // "Goku"
```

---
# 3. Spread Operator (...) & Inmutabilidad

Este es, quizás, el concepto más crítico para entender React.

>[!WARNING] Regla de Oro
>En React, NUNCA modificamos los datos originales (Mutación).
>Siempre creamos una copia nueva con los cambios (Inmutabilidad).

El operador Spread (...) nos permite "esparcir" las propiedades de un objeto/array dentro de uno nuevo.
*Caso*: Agregando elementos a un Array

```JavaScript
const tareas = ["Lavar ropa", "Cocinar"];

// MAL (Mutación - React no se entera de este cambio)
// tareas.push("Estudiar"); 

// BIEN (Inmutabilidad - Creamos un NUEVO array)
// "Copia todo lo que había en tareas, y agrega 'Estudiar' al final"
const nuevasTareas = [...tareas, "Estudiar"];
```

Caso: Actualizando un Objeto

```JavaScript
const perfil = { nombre: "Juan", online: false };

// Queremos cambiar 'online' a true sin tocar el original
const perfilActualizado = {
    ...perfil,       // 1. Copia todas las propiedades viejas
    online: true     // 2. Sobrescribe solo la propiedad 'online'
};

console.log(perfilActualizado); // { nombre: "Juan", online: true }
```

---
# 4. Asincronía y el Event Loop
## Diferencias clave entre sincronía y asincronía

>[!INFO]  NO ES LO MISMO MANEJAR FUNCIONES SINCRONAS QUE ASINCRONAS
>Las funciones **síncronas** ejecutan tareas secuencialmente, bloqueando la ejecución hasta finalizar cada una, ideal para tareas dependientes. 
>Las funciones **asíncronas** permiten iniciar tareas (como consultas a red o archivos) y continuar sin esperar, mejorando la eficiencia y evitando bloqueos. Ambas mejoran la experiencia del usuario, siendo `async/await` comunes en asincronía. 

*Diferencias destacadas:*
  **Ejecución:** Síncrona (paso a paso), Asíncrona (paralela/independiente).
- **Bloqueo:** Síncrona es bloqueante, Asíncrona es no bloqueante.
- **Uso:** Síncrona para tareas rápidas/dependientes; Asíncrona para operaciones de larga duración o I/O (entrada/salida).
## Ejemplo para entenderlo mejor...

JavaScript es Single Threaded (un solo hilo). Solo puede hacer una cosa a la vez. ¿Cómo hace para pedir datos a un servidor sin congelar la pantalla?
La Analogía del Restaurante...
- El Mesero (JS Main Thread): Atiende mesas. No puede entrar a la cocina a cocinar porque dejaría de atender.
- La Cocina (Web APIs): Donde se preparan los pedidos pesados (fetch, timers).
- La fila de platos listos (Callback Queue): Cuando la cocina termina, pone el plato en la ventanilla.
- El Event Loop: Vigila. ¿El mesero está ocupado? No. ¿Hay platos en la ventanilla? Sí. -> ¡Entrega el plato!

---
# 5. Promesas y Async/Await

La evolución de cómo manejamos la espera de datos.
## Async / Await (Azúcar sintáctico)

Hace que el código asíncrono parezca síncrono (línea por línea), haciéndolo mucho más fácil de leer.
*Análisis de Código: Petición a una API*

```JavaScript
// Simulamos una base de datos
const obtenerUsuarios = async () => {
    try {
        console.log("⏳ Cargando...");
        
        // 'await' pausa esta función aquí hasta que fetch responda.
        // Mientras tanto, el resto de la app sigue funcionando.
        const respuesta = await fetch("
(https://jsonplaceholder.typicode.com/users/1)");
        
        if (!respuesta.ok) throw new Error("Error en la petición");

        const datos = await respuesta.json();
        
        console.log("Usuario recibido:", datos.name);
        return datos;

    } catch (error) {
        // Si algo falla arriba (internet, url mal, servidor caído), salta aquí
        console.error("Algo salió mal:", error.message);
    }
};
```

>[!NOTE] Diferencia clave
>Sin await: JS sigue de largo y respuesta sería undefined o una Promesa pendiente.
>Con await: JS espera el resultado antes de pasar a la siguiente línea.

---
# Practica del Día

Objetivo: Crear una función que simule obtener un perfil, actualizarlo y mostrarlo, aplicando todo lo visto.
## Instrucciones 

* Crear una función asíncrona actualizarPerfil.
* Simular una descarga de datos (puedes usar un objeto fijo).
* Usar Destructuring para sacar el nombre y email.
* Usar Spread Operator para crear un objeto nuevoPerfil que agregue la propiedad activo: true y cambie el nombre.
* Imprimir el resultado final.
## Solución:

```JavaScript
const dbUsuario = { id: 1, nombre: "Adrian", email: "camararequeadrianrafael@mail.com", theme: "light" };

const actualizarPerfil = async () => {
    try {
        // 1. Simulamos espera (opcional, solo conceptual)
        // const data = await fetch... (imaginario)
        const data = dbUsuario; 

        // 2. Destructuring
        const { nombre, theme } = data;
        console.log(`Usuario actual: ${nombre}, Tema: ${theme}`);

        // 3. Spread para actualizar inmutablemente
        const usuarioActivo = {
            ...data,        // Copia todo
            activo: true,   // Agrega nuevo
            theme: "dark"   // Sobrescribe existente
        };

        console.log("Nuevo Estado:", usuarioActivo);

    } catch (error) {
        console.log(error);
    }
}

actualizarPerfil();
```
