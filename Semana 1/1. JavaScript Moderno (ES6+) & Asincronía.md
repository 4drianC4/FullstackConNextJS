> [!INFO] Objetivo de la clase
>Actualizar el "chip" mental. En React no usamos bucles `for`, ni modificamos variables directamente, ni usamos `function` antigua. Hoy aprenderemos la sintaxis que usarÃ¡s el 90% del tiempo en el curso.

---
# 1. El cambio de mentalidad

No son solo una forma mÃ¡s corta de escribir; cambian cÃ³mo escribimos lÃ³gica visual.
## Diferencias Clave
1.  **Sintaxis Concisa:** Menos ruido visual.
2.  **Retorno ImplÃ­cito:** Si hay una sola lÃ­nea, no necesitas `return` ni `{}`. (Vital para componentes visuales).
## AnÃ¡lisis de CÃ³digo
```javascript
// JAVASCRIPT ANTIGUO (Imperativo)
function sumar(a, b) {
    return a + b;
}

// JAVASCRIPT MODERNO (Arrow Function)
const sumar = (a, b) => {
    return a + b;
}
// RETORNO IMPLÃCITO (La forma mÃ¡s comÃºn en React)
// "Si lo que sigue a la flecha es una expresiÃ³n, retÃ³rnala automÃ¡ticamente"
const sumar = (a, b) => a + b;
```
---
# 2. DesestructuraciÃ³n (Destructuring)

La capacidad de "sacar" datos de objetos y arreglos y convertirlos en variables individuales en un solo paso.
## DesestructuraciÃ³n de Objetos

Extraer propiedades por su nombre.

```JavaScript
const usuario = {
    nombre: "Ana",
    edad: 28,
    ciudad: "CDMX",
    redes: { twitter: "@ana" }
};

// Forma vieja
const nombre = usuario.nombre;
const ciudad = usuario.ciudad;

// Forma moderna
// "Busca la propiedad 'nombre' y 'ciudad' dentro de usuario y crea variables"
const { nombre, ciudad } = usuario;

// TambiÃ©n funciona con objetos anidados
const { twitter } = usuario.redes;
```
## DesestructuraciÃ³n de Arreglos

Extraer elementos por su posiciÃ³n. (Base de los Hooks como useState).

```JavaScript

const personajes = ["Goku", "Vegeta", "Trunks"];

// "El primero se llamarÃ¡ p1, el segundo p2"
const [p1, p2] = personajes; 

console.log(p1); // "Goku"
```

# 3. Spread Operator (...) & Inmutabilidad
Este es, quizÃ¡s, el concepto mÃ¡s crÃ­tico para entender React.

>[!WARNING] Regla de Oro
>En React, NUNCA modificamos los datos originales (MutaciÃ³n).
>Siempre creamos una copia nueva con los cambios (Inmutabilidad).

El operador Spread (...) nos permite "esparcir" las propiedades de un objeto/array dentro de uno nuevo.
*Caso*: Agregando elementos a un Array
```JavaScript

const tareas = ["Lavar ropa", "Cocinar"];

// MAL (MutaciÃ³n - React no se entera de este cambio)
// tareas.push("Estudiar"); 

// BIEN (Inmutabilidad - Creamos un NUEVO array)
// "Copia todo lo que habÃ­a en tareas, y agrega 'Estudiar' al final"
const nuevasTareas = [...tareas, "Estudiar"];

Caso: Actualizando un Objeto
JavaScript

const perfil = { nombre: "Juan", online: false };

// Queremos cambiar 'online' a true sin tocar el original
const perfilActualizado = {
    ...perfil,       // 1. Copia todas las propiedades viejas
    online: true     // 2. Sobrescribe solo la propiedad 'online'
};

console.log(perfilActualizado); // { nombre: "Juan", online: true }
```
# 4. AsincronÃ­a y el Event Loop
JavaScript es Single Threaded (un solo hilo). Solo puede hacer una cosa a la vez. Â¿CÃ³mo hace para pedir datos a un servidor sin congelar la pantalla?
La AnalogÃ­a del Restaurante...
- El Mesero (JS Main Thread): Atiende mesas. No puede entrar a la cocina a cocinar porque dejarÃ­a de atender.
- La Cocina (Web APIs): Donde se preparan los pedidos pesados (fetch, timers).
- La fila de platos listos (Callback Queue): Cuando la cocina termina, pone el plato en la ventanilla.
- El Event Loop: Vigila. Â¿El mesero estÃ¡ ocupado? No. Â¿Hay platos en la ventanilla? SÃ­. -> Â¡Entrega el plato!

# 5. Promesas y Async/Await
La evoluciÃ³n de cÃ³mo manejamos la espera de datos.
Async / Await (AzÃºcar sintÃ¡ctico)

Hace que el cÃ³digo asÃ­ncrono parezca sÃ­ncrono (lÃ­nea por lÃ­nea), haciÃ©ndolo mucho mÃ¡s fÃ¡cil de leer.
ðŸ” AnÃ¡lisis de CÃ³digo: PeticiÃ³n a una API
JavaScript

// Simulamos una base de datos
const obtenerUsuarios = async () => {
    try {
        console.log("â³ Cargando...");
        
        // 'await' pausa esta funciÃ³n aquÃ­ hasta que fetch responda.
        // Mientras tanto, el resto de la app sigue funcionando.
        const respuesta = await fetch("[https://jsonplaceholder.typicode.com/users/1](https://jsonplaceholder.typicode.com/users/1)");
        
        if (!respuesta.ok) throw new Error("Error en la peticiÃ³n");

        const datos = await respuesta.json();
        
        console.log("Usuario recibido:", datos.name);
        return datos;

    } catch (error) {
        // Si algo falla arriba (internet, url mal, servidor caÃ­do), salta aquÃ­
        console.error("Algo saliÃ³ mal:", error.message);
    }
};

    [!NOTE] Diferencia clave

        Sin await: JS sigue de largo y respuesta serÃ­a undefined o una Promesa pendiente.

        Con await: JS espera el resultado antes de pasar a la siguiente lÃ­nea.

Challenge del DÃ­a (PrÃ¡ctica Guiada)

Objetivo: Crear una funciÃ³n que simule obtener un perfil, actualizarlo y mostrarlo, aplicando todo lo visto.

Instrucciones para el alumno:

    Crear una funciÃ³n asÃ­ncrona actualizarPerfil.

    Simular una descarga de datos (puedes usar un objeto fijo).

    Usar Destructuring para sacar el nombre y email.

    Usar Spread Operator para crear un objeto nuevoPerfil que agregue la propiedad activo: true y cambie el nombre.

    Imprimir el resultado final.

SoluciÃ³n para explicar:
JavaScript

const dbUsuario = { id: 1, nombre: "Adrian", email: "camararequeadrianrafael@mail.com", theme: "light" };

const actualizarPerfil = async () => {
    try {
        // 1. Simulamos espera (opcional, solo conceptual)
        // const data = await fetch... (imaginario)
        const data = dbUsuario; 

        // 2. Destructuring
        const { nombre, theme } = data;
        console.log(`Usuario actual: ${nombre}, Tema: ${theme}`);

        // 3. Spread para actualizar inmutablemente
        const usuarioActivo = {
            ...data,        // Copia todo
            activo: true,   // Agrega nuevo
            theme: "dark"   // Sobrescribe existente
        };

        console.log("Nuevo Estado:", usuarioActivo);

    } catch (error) {
        console.log(error);
    }
}

actualizarPerfil();